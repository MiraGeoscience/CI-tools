name: Publish condan package to Artifactory 

on:
  workflow_call:
    inputs:
        package_manager:
            description: 'Package manager to use (eg. "conda", "poetry", "hatch")'
            required: true
            type: string
            default: 'poetry'
        package_name:
            description: 'Name of the package to build'
            required: true
            type: string
        python_version:
            description: 'Python version to use (eg: 3.10)'
            required: true
            type: string
        version_tag:
            description: 'Version tag of the package to build'
            required: true
            type: string
        lfs:
            description: 'Boolean to indicate if Github LFS is needed'
            required: false
            type: boolean
            default: false
        
        extra_repository:
            description: 'Boolean to indicate if an extra repository is needed to manage the dependencies'
            required: false
            type: boolean
            default: false
        
        repo_names:
            description: 'List with all the names of repositories to publish on (eg. ["analyst-dev-pypi-local", "analyst-pypi-local"])'
            required: true
            type: string

    secrets:
        EXTRA_PYPI_REPO_USER:
            description: 'Extra PyPI repository username for dependencies. Only used if `extra_repository` is True.'
            required: false
        EXTRA_PYPI_REPO_TOKEN:
            description: 'Extra PyPI repository token. Only used if `extra_repository` is True.'
            required: false
        MIRA_REPO_SECRETS:
            description: 'Base64 encoded Yanml file content, containing all the repository secrets'
            required: true

defaults:
    run:
        shell: 'bash -l {0}'

jobs:
    release_pypi_package:
        name: Release PyPI package
        runs-on: ubuntu-latest
        timeout-minutes: 20
        if: ${{ inputs.package_manager != 'conda' }}
        env:
            cache_number: 1
        steps:
            -   uses: actions/checkout@v4
                with:
                    lfs: ${{ inputs.lfs }}
                    fetch-depth: 0
            -   name: Set up Python version
                uses: actions/setup-python@v5
                with:
                    python-version: ${{ inputs.python_version }}
            -   uses: MiraGeoscience/CI-tools/.github/actions/reusable-python-setup_poetry@main
                name: Setup poetry env
                if: ${{ inputs.package_manager == 'poetry' }}
                with:
                    python_ver: ${{ inputs.python_version }}
                    cache_number: ${{ env.cache_number}}
                    runner_os: ${{ runner.os }}
                    extra_repository: ${{ inputs.extra_repository }}
                    repo_user: ${{ secrets.EXTRA_PYPI_REPO_USER }}
                    repo_token: ${{ secrets.EXTRA_PYPI_REPO_TOKEN }}
            -   uses: MiraGeoscience/CI-tools/.github/actions/reusable-python-setup_hatch@main
                name: Setup hatch env
                if: ${{ inputs.package_manager == 'hatch' }}
                with:
                    cache_number: ${{ env.cache_number}}
                    runner_os: ${{ runner.os }}
            -   name: Build package
                run: |
                    if ${{ inputs.package_manager == 'poetry' }}; then
                        poetry build
                    elif ${{ inputs.package_manager == 'hatch'}}; then
                        hatch build
                    else
                        echo "Unknown pypi package manager. ${{ inputs.package_manager }} is not part of ['hatch', 'poetry']."
                        exit 1
                    fi
            -   name: Publish
                run: |
                    MIRA_REPO_CONFIG=$(echo '${{ secrets.MIRA_REPO_SECRETS }}' | base64 -d)
                    repository_list=$(echo '${{ inputs.repo_names }}' | jq -r '.[]')
                    for repo_name in ${repository_list}; do
                        repo_user=$(echo ${MIRA_REPO_CONFIG} | jq -r --arg repo_name "$repo_name" '.repositories[] | select(.name == $repo_name) | .username')
                        repo_token=$(echo ${MIRA_REPO_CONFIG} | jq -r --arg repo_name "$repo_name" '.repositories[] | select(.name == $repo_name) | .token')
                        repo_url=$(echo ${MIRA_REPO_CONFIG} | jq -r --arg repo_name "$repo_name" '.repositories[] | select(.name == $repo_name) | .url')
                        if ${{ inputs.package_manager == 'poetry' }}; then
                            poetry config repositories.${repo_name} ${repo_url} && \
                            poetry publish -r ${repo_name} -u ${repo_user} -p ${repo_token}
                        elif ${{ inputs.package_manager == 'hatch'}}; then
                            hatch publish -r ${repo_url} -u ${repo_user} -a ${repo_token}
                        else
                            echo "Unknown pypi package manager. ${{ inputs.package_manager }} is not part of ['hatch', 'poetry']."
                            exit 1
                        fi
                    done
                    
                    
    release_conda_package:
        name: Release Conda package
        runs-on: ubuntu-latest
        env:
            PYTHONUTF8: 1
            CONDA_CHANNEL_PRIORITY: strict
            PIP_NO_DEPS: 1 # all dependencies are installed from conda
        timeout-minutes: 20
        if: ${{ inputs.package_manager == 'conda' }}
        steps:
            -   name: Checkout
                uses: actions/checkout@v2
                with:
                    lfs: ${{ inputs.lfs }}
            -   name: Check if there is a conda recipe
                run: |
                    if [ -f ${{ inputs.package_name }}/meta.yaml ]; then
                        echo "Conda recipe found"
                    else
                        echo "Conda recipe not found"
                        exit 1
                    fi
            -   name: Setup CONDA_LOCK_ENV_FILE
                run: |
                    os_conda=$( [[ $RUNNER_OS == "Linux" ]] && echo "linux" || ([[ $RUNNER_OS == "Windows" ]] && echo "win" || echo "osx"))
                    
                    echo "CONDA_LOCK_ENV_FILE=environments/py-${{ inputs.python_version }}-${os_conda}-64-dev.conda.lock.yml" >> $GITHUB_ENV
            -   uses: MiraGeoscience/CI-tools/.github/actions/reusable-python-setup_conda@main
                name: Setup conda env
                with:
                  python_ver: ${{ inputs.python_version }}
            -   name: Install dependencies
                run: conda install -y conda-build conda-verify
            -   name: Build package
                id: build_package
                run: |
                    conda build ${{ inputs.package_name }}
                    build_path=$(conda build --output ${{ inputs.package_name }})
                    build_name=$(basename ${build_path})
                    echo "BUILD_PATH=${build_path}" >> $GITHUB_ENV
                    echo "BUILD_NAME=${build_name}" >> $GITHUB_ENV	
            -   name: Publish
                run: |
                    MIRA_REPO_CONFIG=$(echo ${{ secrets.MIRA_REPO_SECRETS }} | base64 -d)
                    repository_list=$(echo '${{ inputs.repo_names }}' | jq -r '.[]')
                    for repo_name in ${repository_list}; do
                        repo_token=$(echo ${MIRA_REPO_CONFIG} | jq -r --arg repo_name "$repo_name" '.repositories[] | select(.name == $repo_name) | .token')
                        repo_url=$(echo ${MIRA_REPO_CONFIG} | jq -r --arg repo_name "$repo_name" '.repositories[] | select(.name == $repo_name) | .url')
                        curl -T ${{ env.BUILD_PATH }} -H "Authorization: Bearer ${repo_token}" "${repo_url}/${{ inputs.package_name }}/${{ inputs.version_tag }}/${{ env.BUILD_NAME }}"
                    done
